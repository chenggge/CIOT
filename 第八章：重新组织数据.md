
### 要点：本章主要解决 *处理数据的重构方式*  的问题
#### 1. Self Encapsulate Field(自封装字段)
* 动机：字段访问有两种方式，当你需要访问基类中的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值。
>1.在这个字段所在的类中，你可以自由访问它。好处：代码比较容易阅读；

>2.即使在这个类中你也应该只使用设值/取值函数间接访问。好处：子类可以通过覆写（基类的）一个函数而改变获取数据的途径，且符合面向对象封装的特征。

* 做法：

>声明字段为private，建立取值，设值函数。

* 范例：

>封装分页实体类时获取总页数。
```
public int getTotalPage() {
if (totalCount < 0) {
totalPage = -1;
}
totalPage = totalCount / pageSize;
if (totalCount % pageSize > 0) {
totalPage++;
}
return totalPage;
}
```
#### 2. Replace Data Value With Object(以对象取代数据值)

* 动机：开发初期，你往往决定以简单的数据项表示简单的情况。但是，随着开发的进行，你可能很快会发现，这些简单的数据项不再那么简单了。这个数据项通常要与其他数据和行为一起使用才有意义。如订单中的客户信息。

* 做法：

>为待替换数值新建一个类，其中包含此此字段，加入其取值函数，构造函数，修改源类待替换字段的取值函数，将其设置函数返回值改新类的一个实例。

* 范例：
>修改前：
```
public class Order {
    private String customer;
    public Order(String customer) {              
        this.customer = customer;
    }
    public String getCustomer() {                                           
        return customer;
    }
    public void setCustomer(String customer) {
        this.customer = customer;
    }
}
```
>修改后：
```
public class Order {
    private Customer customer;
    public Order(String customer) {
        this.customer = new Customer(customer);
    }
    public String getCustomerName() {
        return customer.getName();
    }
    public void setCustomer(String customerName) {
        this.customer = new Customer(customerName);
    }
}
目前Customer还是作为值对象，每个Order都有自己对应的Customer对象。
目标：属于同一客户所有Order对象共享一个Customer对象。
```
#### 3. Change Value to Reference(将值对象改为引用对象)

* 动机：一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象，在值对象（都是不可变字段）中出现一些可修改的字段，并确保对任何对象的修改都能影响到所有引用此对象的地方。

* 做法：使用工厂函数替代调用构造函数，决定由什么对象提供访问新对象的途径（注册表，静态字典），决定引用对象创建方式（预先创建，动态创建），修改工厂函数令他返回引用对象。

* 范例：
```
public class Customer {
    private String name;
    private Customer(String name) {
        this.name = name;
    }
    public static Customer create(String name) {
        return new Customer(name);
    }

 public class Order {
    public Order(String customer) {
        this.customer = Customer.create(customer);//1.使用工厂函数替代调用构造函数
    }
 
 ```
 ```
 public class Customer {
    private static Map<String,Customer> customerMap = new HashMap();// 2.通过注册表来访问
    static void loadCustomers(){                                    //3.预先加载所有Customer
        new Customer("a").store();
        new Customer("b").store();
        new Customer("c").store();
    }
    private void store(){
        customerMap.put(this.getName(),this);
    }
    public static Customer getNamed(String name) { // 修改create方法名称             
        return customerMap.get(name);
    }
 ```
#### 4. Change Reference to Value(将引用对象改为值对象)
* 动机：一个引用对象，很小且不可变，一个对象里面如果能保证无论何时调用一个对象的所有查询函数得到的结果相同，则应该把这个对象变成值对象。

* 做法:检查重构目标是否为不可变对象，或者是否可修改为不可变对象，建立equals和hashcode方法，考虑是否可以删除工厂函数。

* 范例：
 ```
 //作用：返回一个货币种类的引用对象
 class Currency{
    private String code;
    private Currency(String code) {
        this.code = code;
    }
    public String getCode() {
        return code;
    }
}
new Currency("USD").equals(new Currency("USD"));  false
//复写他们的equals和hashcode方法
 public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Currency currency = (Currency) o;
        return code != null ? code.equals(currency.code) : currency.code == null;
    }
    
    public int hashCode() {
        return code != null ? code.hashCode() : 0;
    }
    
    new Currency("USD").equals(new Currency("USD"));  true
 ```
#### 5. Replace Array With Object（以对象取代数组）

* 动机：一个数组内的元素容纳了不用对象,用户需要记住顺序的'隐形约定',容易造成混乱和错误。

* 做法：新建一个类表示数组所拥有的信息，对于每一个元素创建类型相同的字段，修改引用数组部分，改用新的实例。

* 范例：

>修改前：
 ```
    String[] row = new String[3];
    row[0] = "Lakers";
    row[1] = "15";
    row[2] = "3";
 ```
 >修改后：
 ```
    Performance row = new Performance();
    row.setName("Lakers");
    row.setWins("15");
    row.setFails("3");
 ```

#### 6.Duplicate Observed Data（复制“被监视数据”）

* 动机：当MVC出现的时候，极大的推动了Model与View分离的潮流。然而对于一些已存在的老系统或者没有维护好的系统，你都会看到当前存在大把的巨大类----将Model,View,Controller都写在了一个类中。一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。

* 做法：将数据复制到一个领域对象中，建立一个观察者模式用于同步领域对象和GUI对象的重复数据。

#### 7.Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）

* 动机：两个类都需要使用对方特性，但其间只有一条单向连接，需要增加相互关系。

* 做法：在被引用类增加字段，用来保存反向指针，决定由那个类控制关联关系，根据需要在控制或者被控端增加函数来负责更新反向指针。

* 范例：客户保存已有订单集合。

>如何判断关联关系?

>>1.一对多关系，由拥有单一引用方控制。

>>2.某个对象是组成另一部件的对象，则由后者控制。

>>3.多对多关系，任意一个。
 ```
 1.一对多
 public class Customer {
   private Set orders = new HashSet();//保存订单集合
   Set friendOrders(){
       return orders;
   }
}

public class Order {
    private Customer customer_;
    void setCustomer(Customer arg){
        if(customer_ != null){
            arg.friendOrders().remove(this);
            customer_ = arg;
        }
        if(customer_ != null){
            customer_.friendOrders().add(this);
        }
    }
}
  2.多对多
  public class Order {
    private Set customers;
    void addCustomer(Customer arg){
        arg.friendOrders().add(this);
        customers.add(arg);
    }
    void removeCustomer(Customer arg){
        arg.friendOrders().remove(this);
        customers.remove(arg);
    }
}

public class Customer {
   private Set orders = new HashSet();
   Set friendOrders(){
       return orders;
   }
   void addOrder(Order arg){
       arg.addCustomer(this);
   }
   void removeOrder(Order arg){
       arg.removeCustomer(this);
   }
}
  ```

#### 8. Change Bidirectional Association to Bidirectional（将双向关联改为单向关联）

* 动机：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性，维护不必要的双向连接代价很大，容易造成紧耦合，需要去除不必要的关联。

* 做法：删除无效或者冗余关联。

* 范例：上例中，除非先有Customer对象，否则不会存在Order对象，所以可以将从Order到Customer的连接移除掉。
 ```
public class Customer {
   private Set orders = new HashSet();
   Set friendOrders(){
       return orders;
   }
}
public class Order {
    void setCustomer(Customer arg){
        if(arg != null){
            arg.friendOrders().remove(this);
        }
        if(arg != null){
            arg.friendOrders().add(this);
        }
    }
}
 ```
#### 9. Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）

* 动机：具有特殊意义，但是又不能明确表现出这种意义，一旦数值发生改变，必须全部修改。

* 做法：声明一个常量，令其值等于原本魔法数值，以常量替换修改所有引用点。

* 范例：
 ```
    double mathSum(double a){
        return  a * 3.14;
}

static final double CELLRATE = 3.14;
    double mathSum(double a){
        return  CELLRATE * 3.14;
}
 ```
#### 10. Excapsulate Field（封装字段）

* 动机：数据被直接暴露给外部类，高耦合，不安全，封装后只对外暴露调用方法，隐藏起内部实现细节。

* 做法：声明属性为private,提供公共的取值，设值函数。

* 范例：
 ```
public class Customer {
   private String name;
   public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
 ```
#### 11.  Encapsulate Collection（封装集合）

* 动机：取值函数不该返回集合自身，会让用户修改集合但是集合拥有者却一无所知，不应该为这个集合提供设值函数，但是应该提供为集合添加/移除元素的函数。

* 做法：提供为集合添加/移除元素的函数来替代直接返回集合对象。

* 范例：封装集合

>修改前
 ```
public class Person {
    private Set courses;
    public Set getCourses() {
        return courses;
    }
    public void setCourses(Set courses) {
        this.courses = courses;
    }
}
public class Course {
    private String name;
    private boolean isHigh;
}
        Person kent = new Person();
        Set s= new HashSet();
        s.add(new Course("aaa",true));
        s.add(new Course("bbb",false));
        kent.setCourses(s);
        Iterator iter = kent.getCourses().iterator();
        int count = 0;
        while(iter.hasNext()){
            Course course = (Course)iter.next();
            if (course.isHigh()) {
                count ++;
            }
        }
        
 ```
>修改后
```
    private Set cousers = new HashSet();//初始化集合
    public void addCourse (Course course) {//提供操作集合元素的方法
        cousers.add(course);
    }
    public void removeCourse (Course course) {
        cousers.remove(course);
    }
    public void initializeCourses(Set courses) {//直接放入集合方法
        Iterator iter = courses.iterator();
        while (iter.hasNext()) {
            addCourse((Course)iter.next());
        }
        //cousers.addAll(arg)
    }
           public Set getCousers() {
            return Collections.unmodifiableSet(cousers);
    }
    
    
        Person kent = new Person();
        kent.addCourse(new Course("aad",true));
        kent.addCourse(new Course("bbb",false));
    
```
>封装数组
```
    private String[] skills;
    public String[] getSkills() {
        return skills;
    }
    public void setSkills(String[] skills) {
        this.skills = skills;
    }       
    
    
     private List skills = new ArrayList();
    public String[] getSkills() {
        return (String[])skills.toArray(new String[0]);//
    }
   void setSkill(int index, String newSkill) {
       skills.set(index, newSkill);
   }
   
    不带参数的toArray方法，是构造的一个Object数组，然后进行数据拷贝，此时进行转型就会产生ClassCastException;而带参数的toArray方法，则是根据参数数组的类型，构造了一个对应类型的，长度跟ArrayList的size一致的空数组，虽然方法本身还是以Object数组的形式返回结果，不过由于构造数组使用的ComponentType跟需要转型的ComponentType一致，就不会产生转型异常。
```

#### 12.Replace Record with Data Class（以数据类取代记录）

* 动机：传统编程环境，某些数据以较为古老的方式存在；如数据库中部分表没有与之对应的实体类。

* 做法：建立与之对应的类。如javabean实体类。

* 范例：菜单表。

#### 13. 8.13 Replace Type Code With Class（以类取代类型码）

* 动机：接受类型码作为参数的函数，所期望的实际是一个数值，无法强制使用符号名，会大大降低代码的可读性，从而成为bug之源。但是如果将那样的数值替换成一个类，编译器就可以进行校验，只要未这个类提供工厂函数，就可以始终保证只有合法的实例才会被创建，而且它们都会被传递给正确的宿主对象。

* 做法：为类型码建立一个类，修改源类实现，让它使用上述新建的类；

* 范例：
>修改前：
```
public class Person {
  public static final int O = 0;
  public static final int A = 1;
  public static final int B = 2;
  public static final int AB = 3;
  private int _bloodGroup;
  public Person(int bloodGroup){
      _bloodGroup = bloodGroup;
  }
    public int get_bloodGroup() {
        return _bloodGroup;
    }
    public void set_bloodGroup(int _bloodGroup) {
        this._bloodGroup = _bloodGroup;
    }
}

Person person = new Person(Person.A);
```
>修改后：
```
//为类型码新建立一个类
public class BloodGroup
{
    public static final  BloodGroup O = new BloodGroup(0);
    public static final  BloodGroup A = new BloodGroup(1);
    public static final  BloodGroup B = new BloodGroup(2);
    public static final  BloodGroup AB = new BloodGroup(3);
    private static final BloodGroup[] values = {O, A, B, AB};
    private final int _code;
    private BloodGroup(int code) {
        _code = code;
    }
    public static BloodGroup getCode(int arg){
        return values[arg];
    }
}


public class Person {
  private BloodGroup bloodGroup;
    public Person(BloodGroup bloodGroup) {
        this.bloodGroup = bloodGroup;
    }
    public BloodGroup getBloodGroup() {
        return bloodGroup;
    }
    public void setBloodGroup(BloodGroup bloodGroup) {
        this.bloodGroup = bloodGroup;
    }
}

Person person = new Person(BloodGroup.A);
       //取值函数
        Person person = new Person(BloodGroup.A);
        person.getBloodGroup().getCode();        
        //设值函数
        person.setBloodGroup(BloodGroup.AB);

```


#### 14. Replace Type Code with Subclasses（以子类取代类型码） 

* 动机：你有一个不可变的类型码，它会影响类的行为。

* 做法：以子类取代这个类型码。 

* 范例：
```
public class Employee {
    private int type;
    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    public Employee(int type) {
        this.type = type;
    }
```

```
//类型变为子类，覆写类型取值函数
public class Engineer extends Employee {
   public int getType() {
        return 0;
    }
}

public class Employee {
    abstract int getType() ;
    static Employee create(int type) {
        switch (type) {
            case ENGINEER:
                return new Engineer();
            case SALESMAN:
                return new Salesman();
            default:
                throw new IllegalArgumentException("incorrect type code value");
        }
    }
}
```
#### 15. Replace Type Code with State/Strategy（以State/Strategy取代类型码） 

* 动机：你有一个类型码，它会影响类的行为，但是你无法通过继承手法消除它。

* 做法：以状态对象取代类型码。 

* 范例：
```
Employee  对象的类型码是可变的

public class Employee {
    private EmployeeType type;
    public void setType(int type) {
        this.type = EmployeeType.newType(arg);
    }
}

public abstract class EmployeeType {
    private int type;
    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    abstract int getTypeCode();
    static EmployeeType newType(int code) {
        switch (code) {
            case EmployeeType.ENGINEER:
                return new Engineer();
            case EmployeeType.SALESMAN:
                return new Salesman();
            default:
                throw new IllegalArgumentException("incorrect type code value");
        }
    }
}

```
#### 16.Replace Subclass with Field（以字段取代子类） 

* 动机：各个子类的唯一差别只在“返回常量数据”的函数身上。 。

* 做法：修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。

* 范例：
>修改前：
```
public abstract class Person {
 abstract boolean isMale();
 abstract char getCode();
}
class Male extends Person {
    @Override
    boolean isMale() {
        return false;
    }
    @Override
    char getCode() {
        return 'M';
    }
}
class Female extends Person {
    @Override
    boolean isMale() {
        return true;
    }
    @Override
    char getCode() {
        return 'F';
    }
}
```
>修改后：
```
public class Person {
    private final boolean isMale;
    private final char code;
    public Person(boolean isMale, char code) {
        this.isMale = isMale;
        this.code = code;
    }
    static Person createMale() {
        return new Person(true, 'M');
    }
    static Person createFemale() {
        return new Person(false, 'F');
    }
    boolean isMale() {
        return isMale;
}
}
```
