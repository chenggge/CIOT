### 摘要：本章讲述在对象的设计过程中，把责任和特性放在正确的地方
  #### 1. 搬移字段（Move Field）
 * 现象：某个字段被其所驻类之外的另一个类更多地用到
 * 动机：把职责迁移到更适合它的地方去
 * 做法：在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段
 * 例子：
```
class Account {
	private AccountType _type;
	private double _interestRate; //把利率搬移到AccountType类
 
	double interestForAmount_days(double amount, int days) {
		return _interestRate * amount * days / 365;
	}
}


class AccountType {
	private double _interestRate;
 
	void setInterestRate(double rate) {
		_interestRate = rate;
	}
 
	double getInterestRate() {
		return _interestRate;
	}
}
```
 
 
 #### 2. 搬移函数（Move Method）
 * 现象：有函数与其所驻类之外的另一个类进行更多交流：调用后者或被后者调用
 * 动机：两个类并无太多合作，但是出现了高度耦合。
 * 做法：在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移
 * 例一：　　
  ```
class Account {
	private AccountType _type;
	private int _daysOverdrawn; //超期天数
 
	double overdraftCharge() {
		if (_type.isPremium()) {//这个是AccountType类的一个方法，判断是否为高级用户
			double result = 10;
			if (_daysOverdrawn > 7)
				result += (_daysOverdrawn - 7) * 0.85; //超过七天的，每天按照0.85元计费
			return result;
		} else {
			return _daysOverdrawn * 1.75;
		}
	}
}
　
 
 class AccountType {
	double overdraftCharge(int daysOverdrawn) {//透支金额
		if (isPremium()) {  //是否为高级用户
			double result = 10;
			if (daysOverdrawn > 7)
				result += (daysOverdrawn - 7) * 0.85;
			return result;
		} else {
			return daysOverdrawn * 1.75;
		}
	}
}
```
* 注意：   
1.判断要搬移的方法更加亲近与原始类还是新类。这个是为了判断这个函数该不该迁移  
2.注意搬移时所依赖的参数，所有被原函数使用到的参数都要出现在新函数中  
3.搬移后原函数的调用，要么删除原函数，找到原函数所有调用者并重新定向。要么作为一个简单的委托，跳转到新函数  

```
public static void main(String[] args){	//删除原函数
	Account account = new Account(acccountType, 5);
	Double double = account.overdraftCharge();
	
	AccountType accountType = new AccountType();
	accountType.overdraftCharge(account._daysOverdrawn);
}


class Account {//简单的委托
	private AccountType _type;
	private int _daysOverdrawn; //超期天数
	@Deprecated
	double overdraftCharge() {
		return _type.overdraftCharge(_daysOverdrawn); //这里只做跳转，要传入超期天数
	}
}
```
例二：
```
class Customer{ //用户类
    public String statement() { //显示顾客消费金额和利润率
        double totalAmount = 0;
        int frequentRenterPoints = 0;
        Enumeration rentals = _rentals.elements();
        String result = "Rental Record for " + getName() + "\n";
        while (rentals.hasMoreElements()) {
            double thisAmount = 0;
            Rental each = (Rental) rentals.nextElement();

            switch (each.getMovie().get_priceCode()) { //根据不同的电影类型计算租金
                case Movie.REGULAR:
                    thisAmount += 2;
                    if (each.getDaysRented() > 2) {
                        thisAmount += (each.getDaysRented() - 2) * 1.5;
                    }
                    break;
                case Movie.CHILDRENS:
                    thisAmount += each.getDaysRented() * 3;
                    break;
                case Movie.NEW_RELEASE:
                    thisAmount += 1.5;
                    if (each.getDaysRented() > 3) {
                        thisAmount += (each.getDaysRented() - 3) * 1.5;
                    }
                    break;
                default:
                    break;
            }
        }
        result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
        result += "You earned " + String.valueOf(frequentRenterPoints) + " frequent renter points";
        return result;
    }
}
```
搬移函数amountDor到Rental类
```
class Rental{//出租类
    private double amountDor(Rental each) {//传入参数Rental类型
        int thisAmount = 0;
        switch (each.getMovie().get_priceCode()) {
            case Movie.REGULAR:
                thisAmount += 2;
                if (each.getDaysRented() > 2) {
                    thisAmount += (each.getDaysRented() - 2) * 1.5;
                }
                break;
            case Movie.CHILDRENS:
                thisAmount += each.getDaysRented() * 3;
                break;
            case Movie.NEW_RELEASE:
                thisAmount += 1.5;
                if (each.getDaysRented() > 3) {
                    thisAmount += (each.getDaysRented() - 3) * 1.5;
                }
                break;
            default:
                break;
        }
        return thisAmount;
    }
}
```
 #### 3.提炼类（Extract Class）
 * 现象：某个类做了应该由两个类做的事
 * 动机：拥有过多职责的类，责任定位会变得模糊，从而变得难以理解
 * 做法：建立一个新类，将相关的字段和函数从旧类搬移到新类

 #### 4.将类内联化（Inline Class）
 * 现象：某个类没有做太多事情
 * 动机：若一个类没有承担足够大的责任，就没有独立存在的理由
 * 做法：将这个类的所有特性搬移到另一个类中，然后移除原类

 #### 5.隐藏委托关系（Hide Delegate）
 * 现象：客户通过一个委托类来调用另一个对象，如A.getB().doSth()
 * 动机：委托关系如果不隐藏，则客户端需要知道所有的委托关系。一旦委托关系修改，则客户端也需要做相应调整，产生不必要的风险
 * 做法：在服务类上建立客户所需的所有函数，用以隐藏委托关系

 #### 6. 移除中间人（Remove Middle Man）
 * 现象：某个类做了过多的简单委托动作
 * 动机：如果委托类过于简单，则没有存在的必要。因为随着受托类新特性的增加，必须要在委托类上增加相应的委托函数
 * 做法：让客户端直接调用受托类

 #### 7.引入外加函数（Introduce Foreign Method）
 * 现象：你需要为提供服务的类增加一个函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：当jar包提供不了你所需的功能时，需要自己写一个方法进行拓展，以便这个方法可以在许多地方使用
 * 做法：在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例

 #### 8.引入本地扩展（Introduce Local Extension）
 * 现象：你需要为提供服务的类增加一些函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：jar包提供的功能很少，自己需要大量扩展时，把这些扩展函数放到一起便于维护
 * 做法：建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或者包装类
