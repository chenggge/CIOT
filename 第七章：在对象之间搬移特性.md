### 摘要：本章讲述在对象的设计过程中，把责任和特性放在正确的地方
 #### 1. 搬移函数（Move Method）
 * 现象：有函数与其所驻类之外的另一个类进行更多交流：调用后者或被后者调用
 * 动机：两个类并无太多合作，但是出现了高度耦合。
 * 做法：在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移
 * 实例：
   class Account{
      private AccountType _accountType;
      private int _daysOverdrawn;
      
      double OverdraftCharge(){
          if (_accountType.IsPremium()) {
              double result = 10;
              if (_daysOverdrawn > 7) {
                  result += (_daysOverdrawn - 7) * 0.85;
              }
              return result;
          }
          return _daysOverdrawn * 1.75;
      }

      double BankCharge(){
          double result = 4.5;
          if (_daysOverdrawn > 0){
              result += OverdraftCharge();
          }
          return result;
      }
  }

 #### 2. 搬移字段（Move Field）
 * 现象：某个字段被其所驻类之外的另一个类更多地用到
 * 动机：把职责迁移到更适合它的地方去
 * 做法：在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段

 #### 3.提炼类（Extract Class）
 * 现象：某个类做了应该由两个类做的事
 * 动机：拥有过多职责的类，责任定位会变得模糊，从而变得难以理解
 * 做法：建立一个新类，将相关的字段和函数从旧类搬移到新类

 #### 4.将类内联化（Inline Class）
 * 现象：某个类没有做太多事情
 * 动机：若一个类没有承担足够大的责任，就没有独立存在的理由
 * 做法：将这个类的所有特性搬移到另一个类中，然后移除原类

 #### 5.隐藏委托关系（Hide Delegate）
 * 现象：客户通过一个委托类来调用另一个对象，如A.getB().doSth()
 * 动机：委托关系如果不隐藏，则客户端需要知道所有的委托关系。一旦委托关系修改，则客户端也需要做相应调整，产生不必要的风险
 * 做法：在服务类上建立客户所需的所有函数，用以隐藏委托关系

 #### 6. 移除中间人（Remove Middle Man）
 * 现象：某个类做了过多的简单委托动作
 * 动机：如果委托类过于简单，则没有存在的必要。因为随着受托类新特性的增加，必须要在委托类上增加相应的委托函数
 * 做法：让客户端直接调用受托类

 #### 7.引入外加函数（Introduce Foreign Method）
 * 现象：你需要为提供服务的类增加一个函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：当jar包提供不了你所需的功能时，需要自己写一个方法进行拓展，以便这个方法可以在许多地方使用
 * 做法：在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例

 #### 8.引入本地扩展（Introduce Local Extension）
 * 现象：你需要为提供服务的类增加一些函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：jar包提供的功能很少，自己需要大量扩展时，把这些扩展函数放到一起便于维护
 * 做法：建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或者包装类
