##  摘要：本章讲述在对象的设计过程中，把责任和特性放在正确的地方
### 1 搬移字段与方法
  #### 1.1 搬移字段（Move Field）
 * 现象：某个字段被其所驻类之外的另一个类更多地用到
 * 动机：把职责迁移到更适合它的地方去
 * 做法：在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段
 * 例子：把利率搬移到AccountType类
 * 思考：为什么要把利率字段搬移到AccountType类？
```
class Account {
	private AccountType _type;
	private double _interestRate; //利率
 
	double interestForAmount_days(double amount, int days) { //计算日利率金额
		return _interestRate * amount * days / 365;
	}
}


class AccountType {
	private double _interestRate;
 
	void setInterestRate(double rate) {
		_interestRate = rate;
	}
 
	double getInterestRate() {
		return _interestRate;
	}
}
```
* 结论 当多个不同对象拥有相同的属性值时，就可以对这个属性进行搬移
 
 #### 1.2 搬移函数（Move Method）
 * 现象：有函数与其所驻类之外的另一个类进行更多交流：调用后者或被后者调用
 * 动机：两个类并无太多合作，但是出现了高度耦合。
 * 做法：在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移
 * 例一：把Account类中的计算透支金额方法搬移到AccountType类
 * 思考：为什么要把计算透支金额方法搬到AccountType类？
  ```
class Account {
	private AccountType _type;
	private int _daysOverdrawn; //超期天数
 
	double overdraftCharge() { //计算透支金额
		if (_type.isPremium()) {//这个是AccountType类的一个方法，判断是否为高级用户
			double result = 10;
			if (_daysOverdrawn > 7)
				result += (_daysOverdrawn - 7) * 0.85; //超过七天的，每天按照0.85元计费
			return result;
		} else {
			return _daysOverdrawn * 1.75;
		}
	}
}
　
 
 class AccountType {
	double overdraftCharge(int daysOverdrawn) {
		if (isPremium()) {  //是否为高级用户
			double result = 10;
			if (daysOverdrawn > 7)
				result += (daysOverdrawn - 7) * 0.85;
			return result;
		} else {
			return daysOverdrawn * 1.75;
		}
	}
}
```
* 注意：   
1.判断要搬移的方法更加亲近与原始类还是新类。这个是为了判断这个函数该不该迁移  
2.注意搬移时所依赖的参数，所有被原函数使用到的参数都要出现在新函数中  
3.搬移后原函数的调用，要么删除原函数，找到原函数所有调用者并重新定向。要么作为一个简单的委托，跳转到新函数  

```
//方法一：删除原函数
public static void main(String[] args){	
	Account account = new Account(acccountType, 5);
	Double double = account.overdraftCharge();
	
	AccountType accountType = new AccountType();
	accountType.overdraftCharge(account._daysOverdrawn);
}

//方法二：简单的委托
class Account {
	private AccountType _type;
	private int _daysOverdrawn; //超期天数
	@Deprecated      //思考：这里为什么要加这个注解？
	double overdraftCharge() {
		return _type.overdraftCharge(_daysOverdrawn); //这里只做跳转，要传入超期天数
	}
}
```
例二：
```
class Customer{ //用户类
    public String statement() { //显示顾客消费金额和利润率
        double totalAmount = 0;
        int frequentRenterPoints = 0;
        Enumeration rentals = _rentals.elements();
        String result = "Rental Record for " + getName() + "\n";
        while (rentals.hasMoreElements()) {
            double thisAmount = 0;
            Rental each = (Rental) rentals.nextElement();

            switch (each.getMovie().get_priceCode()) { //根据不同的电影类型计算租金
                case Movie.REGULAR:
                    thisAmount += 2;
                    if (each.getDaysRented() > 2) {
                        thisAmount += (each.getDaysRented() - 2) * 1.5;
                    }
                    break;
                case Movie.CHILDRENS:
                    thisAmount += each.getDaysRented() * 3;
                    break;
                case Movie.NEW_RELEASE:
                    thisAmount += 1.5;
                    if (each.getDaysRented() > 3) {
                        thisAmount += (each.getDaysRented() - 3) * 1.5;
                    }
                    break;
                default:
                    break;
            }
        }
        result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
        result += "You earned " + String.valueOf(frequentRenterPoints) + " frequent renter points";
        return result;
    }
}
```
搬移函数amountDor到Rental类
```
class Rental{//出租类
    private double amountDor(Rental each) {//传入参数Rental类型
        int thisAmount = 0;
        switch (each.getMovie().get_priceCode()) {
            case Movie.REGULAR:
                thisAmount += 2;
                if (each.getDaysRented() > 2) {
                    thisAmount += (each.getDaysRented() - 2) * 1.5;
                }
                break;
            case Movie.CHILDRENS:
                thisAmount += each.getDaysRented() * 3;
                break;
            case Movie.NEW_RELEASE:
                thisAmount += 1.5;
                if (each.getDaysRented() > 3) {
                    thisAmount += (each.getDaysRented() - 3) * 1.5;
                }
                break;
            default:
                break;
        }
        return thisAmount;
    }
}
```
### 2  搬移和合并类
 #### 2.1 提炼类（Extract Class）
 * 现象：某个类做了应该由两个类做的事
 * 动机：拥有过多职责的类，责任定位会变得模糊，从而变得难以理解 
 * 做法：建立一个新类，将相关的字段和函数从旧类搬移到新类  
 * 注意：要提出的字段，方法总是一起出现的  
 * 例子：把Person类中的_officeAreaCode，_officeNumber提炼为一个新类
 * 思考：getTelephoneNumber()方法要提取吗？如果有个toString()方法呢,需要提取吗？
```
	class Person { 
		private String _name;
		private String _officeAreaCode; //区号 
		private String _officeNumber;	//电话号
 
		public String get_name() {
			return _name;
		}
 
		public String get_officeAreaCode() {
			return _officeAreaCode;
		}
 
		public void set_officeAreaCode(String areaCode) {
			_officeAreaCode = areaCode;
		}
 
		public String get_officeNumber() {
			return _officeNumber;
		}
 
		public void set_officeNumber(String number) {
			_officeNumber = number;
		}
		
		public String getTelephoneNumber() {  //Data Clumps(数据泥团：总是成群结队出现的一些数据)
			return ("(" + _officeAreaCode + ")" + _officeNumber);
		}
	}
	
	class TelephoneNumber {
		private String _areaCode;
		private String _number;
 
		public String get_AreaCode() {
			return _areaCode;
		}
 
		public void set_AreaCode(String areaCode) {
			_areaCode = areaCode;
		}
 
		public String getNumber() {
			return _number;
		}
 
		public void setNumber(String number) {
			_number = number;
		}
		
		public String getTelephoneNumber() { //获取完整的电话号码
			return ("(" + _areaCode + ")" + _number);
		}
	}
	
	class Person {//提炼了TelephoneNumber类之后的person类

		private TelephoneNumber _officeTelephone = new TelephoneNumber();
		private String _name;
 
		public String get_name() {
			return _name;
		}
 
		public TelephoneNumber getOfficeTelephone() {
			return _officeTelephone;
		}
		
		public String getTelephoneNumber() {
			return _officeTelephone.getTelephoneNumber();
		}

}
```
注意：  
1.提取原则：我们把关系较为接近的，或者总是成对出现的字段和方法提取出来形成一个新类。  
2.原始类需要引入提炼类的属性，修改原始类对分离出的属性的调用  


 #### 2.2 将类内联化（Inline Class）
 * 现象：某个类没有做太多事情
 * 动机：若一个类没有承担足够大的责任，就没有独立存在的理由
 * 做法：将这个类的所有特性搬移到另一个类中，然后移除原类
 * 理解：内联化和提炼类刚好是一组相反的行为，提炼类是把新类从原始类中分离出来，而内联化是把新类还原到原始类中。  
 * 思考：什么时候应该提炼类，什么时候应该内联化？  
 
### 3  隐藏与封装
 #### 3.1隐藏委托关系
 * 现象：客户通过一个委托类来调用另一个对象，如A.getB().doSth()
 * 动机：委托关系如果不隐藏，则客户端需要知道所有的委托关系。一旦委托关系修改，则客户端也需要做相应调整，产生不必要的风险
 * 做法：在服务类上建立客户所需的所有函数，用以隐藏委托关系
```
public class Person {
    private String name;
    private TelephoneNumber telNum;

    public Person(String name, String areaCode, String number) {
        this.name = name;
        telNum = new TelephoneNumber(areaCode, number);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public TelephoneNumber getTelNum() {
        return telNum;
    }

    public void setTelNum(TelephoneNumber telNum) {
        this.telNum = telNum;
    }

}

public class TelephoneNumber {
    private String areaCode;
    private String number;

    public TelephoneNumber(String areaCode, String number) {
        super();
        this.areaCode = areaCode;
        this.number = number;
    }

    public String getAreaCode() {
        return areaCode;
    }

    public void setAreaCode(String areaCode) {
        this.areaCode = areaCode;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }
    
   public String getTelephoneNumber() { //返回完整电话
        return getAreaCode() + "-" + getNumber(); 
    }
}

public class Test {
    public static void main(String[] args) {
        Person person = new Person("ZK", "029", "99999999");
        // 显式调用委托对象的方法
        String telephoneNum = person.getTelNum().getTelephoneNumber();    
    }
}

//进行隐藏委托关系
public class Person {
    private String name;
    private TelephoneNumber telNum;

    public Person(String name, String areaCode, String number) {
        this.name = name;
        telNum = new TelephoneNumber(areaCode, number);
    }

    public String getTelephoneNumber() {\\这个函数被称为委托函数
        return telNum.getTelephoneNumber(); \\在这里调用了TelephoneNumber类的getTelephoneNumber()方法
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}

public class Test {
    public static void main(String[] args) {
        Person person = new Person("ZK", "029", "99999999");
        // 隐藏委托关系
        String telephoneNum = person.getTelephoneNumber();
    }

}
```

 	
 	
 #### 3.2. 移除中间人（Remove Middle Man）
 * 现象：某个类做了过多的简单委托动作
 * 动机：如果委托类过于简单，则没有存在的必要。因为随着受托类新特性的增加，必须要在委托类上增加相应的委托函数
 * 做法：让客户端直接调用受托类
 * 理解：隐藏委托管理的这种思想是一种‘封装’的思想，减少客户对对象之间关系的了解，把函数之间的委托关系限制在服务对象中，不会调用者产生影响。
 	 移除中间人和隐藏委托关系是一组相反的行为，移除中间人是为了解开封装，让调用过程更加清晰的显示出来。  
 * 从搬移特性的角度理解封装：  
   ```
   优点：  
	* 封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。--->举例说明：搬移电话区号字段形成一个新类  
	* “高内聚”：封装细节，便于修改内部代码，提高可维护性，安全性。 -->思考：为什么提高了可维护性，安全性呢？  
	* “低耦合”：简化外部调用，便于调用者使用，提高代码的复用性。		
   缺点：  
	* 每当客户要使用受托类（TelephoneNumber类）的新特性时，你就必须在客户类（Person类）端添加一个简单委托函数。但是，随着受托类的特性		      越来越多，服务器端对应添的特性也就越来越多。这时，应该让客户直接调用受托类。 
   ```
  
 * 思考：什么时候应该隐藏委托关系，什么时候应该移除中间人，直接调用受托类呢？  
 	    很难说在什么情况下的隐藏才是比较合适的。因为可以在系统运行过程中不断进行调整。随着系统的不断变化，“隐藏程度”选取尺度也相应变化。可能一些	委托关系需要保留，而另一些却需要移除，让客户直接使用受托对象。这些都是可以随之变通的。
	    对于各种不同重构手法的使用，同样没有绝对的规定，都是需要依据实际灵活使用的。真所谓“唯变通才能立于不败也”。
 
### 4 添加新函数
 #### 4.1 引入外加函数（Introduce Foreign Method）
 * 现象：你需要为提供服务的类增加一个函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：当jar包提供不了你所需的功能时，需要自己写一个方法进行拓展，以便这个方法可以在许多地方使用
 * 做法：在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例
 * 实例：获取Date类型一天后的对象
 ```
class Date {
...
//创建一个构造函数：返回一个他的后一天的对象
  
   public Date (int year, int month, int date) {
       //具体实现
       '''
   }
    
}

class Test {
    public ststic void main (String[] args){
        //以服务类(Date类)的实例作为这个函数的第一个参数
	Date newStart = nextDay(new Date());
   
    }
    
    //在客户类(Test类)中建立一个函数nextDay()，用来提供你需要的功能。这个函数不应该调用客户类的任何特性。 思考：为什么不能？
    public static Date nextDay(Date arg) 
    //为了避免引用客户类的特性，我们可以在新创建的函数给他static特性
    {
        return new Date(arg.getYear(), arg.getMonth(), arg.getDate()+ 1);
    }
}
 ```
 #### 4.2 引入本地扩展（Introduce Local Extension）
 * 现象：你需要为提供服务的类增加一些函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：jar包提供的功能很少，自己需要大量扩展时，把这些扩展函数放到一起便于维护
 * 做法：如果你只需一两个函数，使用引入外加函数（Introduce Foreign Method）就可以解决问题。如果你需要的函数较多，那么建立一个新类，使它包含这些额外		函数。让这个扩展品成为源类的子类或者包装类
 * 思考：为什么要形成一个新类，而不是多引入几个外加函数来解决问题呢？
 	把本该放在扩展类中的代码零零散散的放在客户类中，让客户类变得复杂而且难以维护，难以被复用。
 * 实例：
```
public class ConcreateCalendar extends Calendar {//原始类
    private Date today;

    public ConcreateCalendar(String dateStr, String format) {
        super();
        try {
            today = new SimpleDateFormat(format).parse(dateStr);
        } catch (ParseException e) {
            today = new Date();
        }
    }

    public Date getToday() {
        return today;
    }

    public void setToday(Date today) {
        this.today = today;
    }

    public int getGreatestMinimum(int field) {
        return 0;
    }

    public int getLeastMaximum(int field) {
        return 0;
    }

}

/**
 * 子类化方案：它提供原始类的一切特性，同时额外添加新特性，在任何使用原类的地方，你都可以使用新类取而代之
 */
public class LocalExtensionBySubClass extends ConcreateCalendar {

    /**
     * 转型构造函数
     * @param dateStr
     * @param format
     */
    public LocalExtensionBySubClass(String dateStr, String format) {
        super(dateStr, format);
    }

    /**
     * 下一个日期
     */
    public Date nextDate() {
        setTime(this.getToday());
        add(Calendar.DAY_OF_YEAR, 1);
        return getTime();
    }

    /**
     * 下一个月份
     */
    public Date nextMonth() {
        setTime(this.getToday());
        add(Calendar.MONTH, 1);
        return getTime();
    }

    /**
     * 下一年
     */
    public Date nextYear() {
        setTime(this.getToday());
        add(Calendar.YEAR, 1);
        return getTime();
    }

}


/**
 * 包装类方案
 */
public class ConcreateCalendarWrap {
    private Calendar cal;

    /**
     * 转型构造函数
     * @param cal
     */
    public ConcreateCalendarWrap(Calendar cal) {
        super();
        this.cal = cal;
    }
 
    //第一件事：为原始类的所有函数提供委托函数 
	    public Date getToday(){
		return cal.getToday(); //这里是原始类跳转
	    }
	    public void setToday(Date today) {
		...
	    }
	    public int getGreatestMinimum(int field) {
		...
	    }
 	    public int getLeastMaximum(int field) {
        	...
	    }
    //第二件事：添加新方法
 
	    /**
	     * 下一个日期
	     * @return
	     */
	    public Date nextDate() {
		cal.add(Calendar.DAY_OF_YEAR, 1);
		return cal.getTime();
	    }

	    /**
	     * 下一个月份
	     * @return
	     */
	    public Date nextMonth() {
		cal.add(Calendar.MONTH, 1);
		return cal.getTime();
	    }

	    /**
	     * 下一年
	     * @return
	     */
	    public Date nextYear() {
		cal.add(Calendar.YEAR, 1);
		return cal.getTime();
	    }

	    public Date getTime() {
		return cal.getTime();
	    }

	    public void add(int field, int amount) {
		cal.add(field, amount);
	    }

}
 ```
 * 思考：什么时候使用子类，什么时候使用包装类？
 
