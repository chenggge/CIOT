##  摘要：本章讲述在对象的设计过程中，把责任和特性放在正确的地方
### 1 搬移字段与方法
  #### 1.1 搬移字段（Move Field）
 * 现象：某个字段被其所驻类之外的另一个类更多地用到
 * 动机：把职责迁移到更适合它的地方去
 * 做法：在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段
 * 例子：把利率搬移到AccountType类
 * 思考：为什么要把利率字段搬移到AccountType类？
```
class Account {
	private AccountType _type;
	private double _interestRate; //利率
 
	double interestForAmount_days(double amount, int days) { //计算日利率金额
		return _interestRate * amount * days / 365;
	}
}


class AccountType {
	private double _interestRate;
 
	void setInterestRate(double rate) {
		_interestRate = rate;
	}
 
	double getInterestRate() {
		return _interestRate;
	}
}
```
* 结论 当多个不同对象拥有相同的属性值时，就可以对这个属性进行搬移
 
 #### 1.2 搬移函数（Move Method）
 * 现象：有函数与其所驻类之外的另一个类进行更多交流：调用后者或被后者调用
 * 动机：两个类并无太多合作，但是出现了高度耦合。
 * 做法：在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移
 * 例一：把Account类中的计算透支金额方法搬移到AccountType类
 * 思考：为什么要把计算透支金额方法搬到AccountType类？
  ```
class Account {
	private AccountType _type;
	private int _daysOverdrawn; //超期天数
 
	double overdraftCharge() { //计算透支金额
		if (_type.isPremium()) {//这个是AccountType类的一个方法，判断是否为高级用户
			double result = 10;
			if (_daysOverdrawn > 7)
				result += (_daysOverdrawn - 7) * 0.85; //超过七天的，每天按照0.85元计费
			return result;
		} else {
			return _daysOverdrawn * 1.75;
		}
	}
}
　
 
 class AccountType {
	double overdraftCharge(int daysOverdrawn) {
		if (isPremium()) {  //是否为高级用户
			double result = 10;
			if (daysOverdrawn > 7)
				result += (daysOverdrawn - 7) * 0.85;
			return result;
		} else {
			return daysOverdrawn * 1.75;
		}
	}
}
```
* 注意：   
1.判断要搬移的方法更加亲近与原始类还是新类。这个是为了判断这个函数该不该迁移  
2.注意搬移时所依赖的参数，所有被原函数使用到的参数都要出现在新函数中  
3.搬移后原函数的调用，要么删除原函数，找到原函数所有调用者并重新定向。要么作为一个简单的委托，跳转到新函数  

```
//方法一：删除原函数
public static void main(String[] args){	
	Account account = new Account(acccountType, 5);
	Double double = account.overdraftCharge();
	
	AccountType accountType = new AccountType();
	accountType.overdraftCharge(account._daysOverdrawn);
}

//方法二：简单的委托
class Account {
	private AccountType _type;
	private int _daysOverdrawn; //超期天数
	@Deprecated
	double overdraftCharge() {
		return _type.overdraftCharge(_daysOverdrawn); //这里只做跳转，要传入超期天数
	}
}
```
例二：
```
class Customer{ //用户类
    public String statement() { //显示顾客消费金额和利润率
        double totalAmount = 0;
        int frequentRenterPoints = 0;
        Enumeration rentals = _rentals.elements();
        String result = "Rental Record for " + getName() + "\n";
        while (rentals.hasMoreElements()) {
            double thisAmount = 0;
            Rental each = (Rental) rentals.nextElement();

            switch (each.getMovie().get_priceCode()) { //根据不同的电影类型计算租金
                case Movie.REGULAR:
                    thisAmount += 2;
                    if (each.getDaysRented() > 2) {
                        thisAmount += (each.getDaysRented() - 2) * 1.5;
                    }
                    break;
                case Movie.CHILDRENS:
                    thisAmount += each.getDaysRented() * 3;
                    break;
                case Movie.NEW_RELEASE:
                    thisAmount += 1.5;
                    if (each.getDaysRented() > 3) {
                        thisAmount += (each.getDaysRented() - 3) * 1.5;
                    }
                    break;
                default:
                    break;
            }
        }
        result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
        result += "You earned " + String.valueOf(frequentRenterPoints) + " frequent renter points";
        return result;
    }
}
```
搬移函数amountDor到Rental类
```
class Rental{//出租类
    private double amountDor(Rental each) {//传入参数Rental类型
        int thisAmount = 0;
        switch (each.getMovie().get_priceCode()) {
            case Movie.REGULAR:
                thisAmount += 2;
                if (each.getDaysRented() > 2) {
                    thisAmount += (each.getDaysRented() - 2) * 1.5;
                }
                break;
            case Movie.CHILDRENS:
                thisAmount += each.getDaysRented() * 3;
                break;
            case Movie.NEW_RELEASE:
                thisAmount += 1.5;
                if (each.getDaysRented() > 3) {
                    thisAmount += (each.getDaysRented() - 3) * 1.5;
                }
                break;
            default:
                break;
        }
        return thisAmount;
    }
}
```
### 2  搬移和合并类
 #### 2.1 提炼类（Extract Class）
 * 现象：某个类做了应该由两个类做的事
 * 动机：拥有过多职责的类，责任定位会变得模糊，从而变得难以理解 
 * 做法：建立一个新类，将相关的字段和函数从旧类搬移到新类  
 * 注意：要提出的字段，方法总是一起出现的  
 * 例子：
```
	class Person { 
		private String _name;
		private String _officeAreaCode; //区号
		private String _officeNumber;	//电话号
 
		public String get_name() {
			return _name;
		}
 
		public String getTelephoneNumber() {
			return ("(" + _officeAreaCode + ")" + _officeNumber);
		}
 
		public String get_officeAreaCode() {
			return _officeAreaCode;
		}
 
		public void set_officeAreaCode(String areaCode) {
			_officeAreaCode = areaCode;
		}
 
		public String get_officeNumber() {
			return _officeNumber;
		}
 
		public void set_officeNumber(String number) {
			_officeNumber = number;
		}
	}
	
	class TelephoneNumber {
		private String _areaCode;
		private String _number;
 
		public String get_AreaCode() {
			return _areaCode;
		}
 
		public void set_AreaCode(String areaCode) {
			_areaCode = areaCode;
		}
 
		public String getNumber() {
			return _number;
		}
 
		public void setNumber(String number) {
			_number = number;
		}
		
		public String getTelephoneNumber() { //获取完整的电话号码
			return ("(" + _areaCode + ")" + _number);
		}
	}
	
	class Person {//提炼了TelephoneNumber类之后的person类

		private TelephoneNumber _officeTelephone = new TelephoneNumber();
		private String _name;
 
		public String get_name() {
			return _name;
		}
 
		public TelephoneNumber getOfficeTelephone() {
			return _officeTelephone;
		}
		
		public String getTelephoneNumber() {
			return _officeTelephone.getTelephoneNumber();
		}

}
```


 #### 2.2 将类内联化（Inline Class）
 * 现象：某个类没有做太多事情
 * 动机：若一个类没有承担足够大的责任，就没有独立存在的理由
 * 做法：将这个类的所有特性搬移到另一个类中，然后移除原类
 * 实例：内联化和提炼类刚好是一组相反的行为，提炼类是把新类从原始类中分离出来，而内联化是把新类还原到原始类中。
### 3  隐藏与封装
 #### 3.1隐藏委托关系
 * 现象：客户通过一个委托类来调用另一个对象，如A.getB().doSth()
 * 动机：委托关系如果不隐藏，则客户端需要知道所有的委托关系。一旦委托关系修改，则客户端也需要做相应调整，产生不必要的风险
 * 做法：在服务类上建立客户所需的所有函数，用以隐藏委托关系
```
public class Person {

    private String name;

    private TelephoneNumber telNum;

    public Person(String name, String areaCode, String number) {
        this.name = name;
        telNum = new TelephoneNumber(areaCode, number);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public TelephoneNumber getTelNum() {
        return telNum;
    }

    public void setTelNum(TelephoneNumber telNum) {
        this.telNum = telNum;
    }

}

public class TelephoneNumber {

    private String areaCode;

    private String number;

    public TelephoneNumber(String areaCode, String number) {
        super();
        this.areaCode = areaCode;
        this.number = number;
    }

    public String getAreaCode() {
        return areaCode;
    }

    public void setAreaCode(String areaCode) {
        this.areaCode = areaCode;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }
    
   public String getTelephoneNumber() {
        return getAreaCode() + "-" + getNumber(); //返回完整电话
    }
}

public class Test {
    public static void main(String[] args) {
        Person person = new Person("ZK", "029", "99999999");
        // 显式调用委托对象的方法
        String telephoneNum = person.getTelNum().getTelephoneNumber();    
    }
}

//进行隐藏委托关系
public class Person {

    private String name;

    private TelephoneNumber telNum;

    public Person(String name, String areaCode, String number) {
        this.name = name;
        telNum = new TelephoneNumber(areaCode, number);
    }

    public String getTelephoneNumber() {\\这个函数被称为委托函数
        return telNum.getTelephoneNumber(); \\在这里调用了TelephoneNumber类的getTelephoneNumber()方法
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}

public class Test {
    public static void main(String[] args) {
        Person person = new Person("ZK", "029", "99999999");
        // 隐藏委托关系
        String telephoneNum = person.getTelephoneNumber();
    }

}
```
 * 理解：隐藏委托管理的这种思想是一种‘封装’的思想，减少客户对对象之间关系的了解，把函数之间的委托关系限制在服务对象中，不会调用者产生影响
 #### 3.2. 移除中间人（Remove Middle Man）
 * 现象：某个类做了过多的简单委托动作
 * 动机：如果委托类过于简单，则没有存在的必要。因为随着受托类新特性的增加，必须要在委托类上增加相应的委托函数
 * 做法：让客户端直接调用受托类
 * 实例：移除中间人和隐藏委托关系是一组相反的行为，移除中间人是为了解开封装，让调用过程更加清晰的显示出来。
### 4
 #### 4.1 引入外加函数（Introduce Foreign Method）
 * 现象：你需要为提供服务的类增加一个函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：当jar包提供不了你所需的功能时，需要自己写一个方法进行拓展，以便这个方法可以在许多地方使用
 * 做法：在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例
 * 实例：
 ```
 import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class IntroduceForeignMethod {

    public static void main(String[] args) throws ParseException {

        Calendar cal = Calendar.getInstance();
        System.out.println("当前时间：\n" + cal.getTime());

        //
        System.out.println("执行Calendar类的外加函数nextDate");
        IntroduceForeignMethod fm = new IntroduceForeignMethod();
        Date nextDate = fm.nextDate(Calendar.getInstance());
        System.out.println(nextDate);

        //
        System.out.println("执行Calendar类的外加函数truncateDate");
        System.out.println(fm.truncateDate(cal));

        //
        System.out.println("执行Date类的外加函数truncate");
        Date trunDate = fm.truncate(cal.getTime(), "yyyy/MM/dd");
        System.out.println(trunDate);
    }

    /**
     * 获取下一天的日期<br/>
     * 外加函数, 应在Calendar类中
     * @param cal
     * @return
     */
    public Date nextDate(Calendar cal) {
        cal.add(Calendar.DAY_OF_YEAR, 1);
        Date nextDate = cal.getTime();
        return nextDate;
    }

    /**
     * 截取日期，只保留年月日<br/>
     * 外加函数, 应在Calendar类中
     * @param cal
     * @return
     */
    public Date truncateDate(Calendar cal) {
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        return cal.getTime();
    }

    /**
     * 根据指定格式截取日期<br/>
     * 外加函数, 应在Date类中
     * @param date
     * @param format
     * @return
     */
    public Date truncate(Date date, String format) throws ParseException {
        if (date == null || format == null) {
            return date;
        }
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        return sdf.parse(sdf.format(date));
    }

}
 ```
 #### 4.2 引入本地扩展（Introduce Local Extension）
 * 现象：你需要为提供服务的类增加一些函数，但是你无法修改这个类（如一个jar包无法修改源码）
 * 动机：jar包提供的功能很少，自己需要大量扩展时，把这些扩展函数放到一起便于维护
 * 做法：建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或者包装类
 * 实例：
 ```
 import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class ConcreateCalendar extends Calendar {

    private static final long serialVersionUID = -4133479289114370006L;

    private Date today;

    public ConcreateCalendar(String dateStr, String format) {
        super();
        try {
            today = new SimpleDateFormat(format).parse(dateStr);
        } catch (ParseException e) {
            today = new Date();
        }
    }

    public Date getToday() {
        return today;
    }

    public void setToday(Date today) {
        this.today = today;
    }

    protected void computeTime() {
        // TODO Auto-generated method stub

    }

    protected void computeFields() {
        // TODO Auto-generated method stub

    }

    public void add(int field, int amount) {
        // TODO Auto-generated method stub

    }

    public void roll(int field, boolean up) {
        // TODO Auto-generated method stub

    }

    public int getMinimum(int field) {
        // TODO Auto-generated method stub
        return 0;
    }

    public int getMaximum(int field) {
        // TODO Auto-generated method stub
        return 0;
    }

    public int getGreatestMinimum(int field) {
        // TODO Auto-generated method stub
        return 0;
    }

    public int getLeastMaximum(int field) {
        // TODO Auto-generated method stub
        return 0;
    }

}

import java.util.Calendar;
import java.util.Date;
/**
 * 子类化方案
 *
 */
public class LocalExtensionBySubClass extends ConcreateCalendar {

    private static final long serialVersionUID = -3645662145076608166L;

    /**
     * 转型构造函数
     * @param dateStr
     * @param format
     */
    public LocalExtensionBySubClass(String dateStr, String format) {
        super(dateStr, format);
    }

    /**
     * 下一个日期
     * @return
     */
    public Date nextDate() {
        setTime(this.getToday());
        add(Calendar.DAY_OF_YEAR, 1);
        return getTime();
    }

    /**
     * 下一个月份
     * @return
     */
    public Date nextMonth() {
        setTime(this.getToday());
        add(Calendar.MONTH, 1);
        return getTime();
    }

    /**
     * 下一年
     * @return
     */
    public Date nextYear() {
        setTime(this.getToday());
        add(Calendar.YEAR, 1);
        return getTime();
    }

}

import java.util.Calendar;
import java.util.Date;
/**
 * 包装类方案
 *
 */
public class ConcreateCalendarWrap {

    private Calendar cal;

    /**
     * 转型构造函数
     * @param cal
     */
    public ConcreateCalendarWrap(Calendar cal) {
        super();
        this.cal = cal;
    }

    /**
     * 下一个日期
     * @return
     */
    public Date nextDate() {
        cal.add(Calendar.DAY_OF_YEAR, 1);
        return cal.getTime();
    }

    /**
     * 下一个月份
     * @return
     */
    public Date nextMonth() {
        cal.add(Calendar.MONTH, 1);
        return cal.getTime();
    }

    /**
     * 下一年
     * @return
     */
    public Date nextYear() {
        cal.add(Calendar.YEAR, 1);
        return cal.getTime();
    }

    public Date getTime() {
        return cal.getTime();
    }

    public void add(int field, int amount) {
        cal.add(field, amount);
    }

}
 ```
