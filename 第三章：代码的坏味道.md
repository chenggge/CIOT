### 要点：本章主要解决 *我们应该何时进行重构*  的问题
#### 1. Duplicated Code(重复代码)
* 同一个类的两个函数含有相同的表达式
* 两个互为兄弟的子类内含相同表达式
#### 2. Long Method(过长函数)
* 小型函数
> 现代OO语言几乎已经完全免除了进程内的函数调用开销。
* 给函数起个好名字--小函数容易理解的真正关键
> 关键不在于函数的长度，而在于函数**做什么**和**如何做**之间的语义距离。
* 分解函数--方法
> 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其**用途**(而非实现手法)命名。
* 如何确定该提炼哪一段代码
> * 寻找注释
> * 条件表达式和循环
#### 3. Long Class(过大的类)
* 太多的实例变量
* 太多的代码
#### 4. Long Parameter List(过长参数列)
* 全局数据是邪恶的东西，所以我们需要参数
> 对象技术改变了这一情况：如果你手上没有所需的东西，总可以叫另一个对象给你。因此，有了对象，你就不必把函数需要的东西都以参数传递给它了，只需传给它足够的、让函数能从中获得自己需要的东西就行了。
* 传入对象优于传入参数
#### 5. Divergent Change(发散式变化)
* 一个类受多种变化影响
* > 如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。
* > 针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。为此，你应该找出某特定原因而造成的所有变化，并将它们提炼到另一个类中。
* 一个类用于解决某一个问题
#### 6. Shotgun Surgery(散弹式修改)
* 一种变化引发多个类相应修改
* > 如果没遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是Shotgun Surgery。
* > 这两种情况下你都会希望整理代码，使“外界变化”与“需要修改的类趋于一一对应”。
#### 7. Feature Envy(依恋情结)
* > 对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”的技术。
* > 有一种经典气味是：函数对某个类的兴趣高过对自己所处类的兴趣。这种如慕之情最通常的焦点便是数据。
* > 一个函数往往会用到几个类的功能，那么它究竟该被置于何处呢？我们的原则是：判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。
#### 8. Data Clumps(数据泥团)
* > 数据项就像小孩子，喜欢成群结队的待在一块儿。你可以在很多地方看到相同的三四项数据：两个类中相同的字段，许多函数签名中相同的参数。
* > 一个好的评判方法是：删掉众多数据项中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确信号：你应该为它们产生一个新对象。不必在意Data Clumps只用上新对象的一部分字段，只要以新对象取代两个（或者更多）字段，你就值回票价了。
#### 9. Primitive Obsession（基本类型偏执）
> 大多数编程环境都有两种数据：结构类型允许你讲数据组织成有意义的形式；基本类型则是构成结构类型的积木块。
> 对象的一个极大的价值在于：它们模糊（甚至打破）了横亘与基本数据和体积较大的类之间的界限。
#### 10. Switch Statements(switch惊悚现身)
> 面向对象程序的一个最明显的特征就是：少用switch(或case)语句。从本质上说，switch语句的问题在于重复。
#### 11. Parallel Inheritance Hierarchies(平行继承体系)
> Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。
#### 12. Lazy Class(冗余类)
> 如果一个类的所得不值其身价，它就应该消失。
> * 项目中经常会出现这样的情况：某个类原本对的起自己的身价，但重构使它身形缩水，不再做那么多工作；
> * 或开发者事前规划了某些变化，并添加一个类来应付这些变化，但变化实际没有发生。
#### 13. Speculative Generality(夸夸其谈未来性)
> 当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。
#### 14. Temporary Field(令人迷惑的暂时字段)
> 有时你会看到这样的对象：其内某个实例变量仅为某些特定情况而设。
#### 15. Message Chains(过度耦合的消息链)
> 如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。
> 实际代码中你看到的可能是一长串getThis()或一长串临时变量。采取这种方式，意味客户代码将于查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。
#### 16. Middle Man(中间人)
> 对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着**委托**。
> 但是人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这就是过度运用。
> 减少中间人，直接和负责的对象打交道。
#### 17. Inappropriate Intimacy(狎昵关系)
> 有时你会看到两个类过于亲密，花费太多时间去探究彼此的privite成分。过分狎昵必须拆散。
> 继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。
#### 18. Alternative Classes with Different Interfaces(异曲同工的类)
> 如果两个函数做同一件事，却有着不同的签名。
#### 19. Incomplete Library Class(不完美的类)
> 复用常被视为对象的终极目的。许多编程技术多建立在程序库的基础上。
> 库作者的任务真的很艰巨。库类构筑者没有未卜先知的能力，麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类使它完成我们所希望完成的工作。
#### 20. Data Class(纯稚的数据类)
> 所谓Data Class是指：它们拥有一些字段，以及用于访问(读写)这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细碎的操控着。
#### 21. Refused Bequest(被拒绝的遗赠)
> 子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢?它们得到所有礼物，却只从中挑选几样来玩！
#### 22. Comments(过多的注释)
* > 常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。
* > 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。
* > 如果你不知道该做什么，这才是注释的良好时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己“什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。


